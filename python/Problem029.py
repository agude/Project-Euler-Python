#!/usr/bin/env python3

#  Copyright (C) 2014  Alexander Gude - alex.public.account+ProjectEulerSolutions@gmail.com
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  The most recent version of this program is available at:
#  https://github.com/agude/Project-Euler

"""
Consider all integer combinations of a**b for 2 <= a <= 5 and 2 <= b <= 5:

    2**2 = 4, 2**3 = 8, 2**4 = 16, 2**5 = 32
    3**2 = 9, 3**3 = 27, 3**4 = 81, 3**5 = 243
    4**2 = 16, 4**3 = 64, 4**4 = 256, 4**5 = 1024
    5**2 = 25, 5**3 = 125, 5**4 = 625, 5**5 = 3125

If they are then placed in numerical order, with any repeats removed, we get
the following sequence of 15 distinct terms:

4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125

How many distinct terms are in the sequence generated by a**b for 2 < a < 100
and 2 < b < 100?
"""

# Only runs if executed directly
if __name__ == '__main__':
    from time import time
    from optparse import OptionParser

    # Optparse setup
    usage = "usage: %prog [OPTIONS]"
    parser = OptionParser(usage=usage)
    parser.add_option("-a", action="store", type="int", dest="AMAX", default=100, help="calculate a**b for 2 <= a <= AMAX")
    parser.add_option("-b", action="store", type="int", dest="BMAX", default=100, help="calculate a**b for 2 <= b <= BMAX")

    (options, args) = parser.parse_args()

    # Constants
    A_MAX = options.AMAX
    B_MAX = options.BMAX

    # Solution
    start_time = time()

    # We use a set to track the unique numbers
    unique_numbers = set([])
    for a in range(2, A_MAX + 1):
        for b in range(2, B_MAX+1):
            unique_numbers.add(a ** b)

    length = len(unique_numbers)

    end_time = time() - start_time
    print(length, 'in', end_time, 'secs')
